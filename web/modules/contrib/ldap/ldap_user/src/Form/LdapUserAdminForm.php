<?php

namespace Drupal\ldap_user\Form;

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Form\ConfigFormBase;
use \Drupal\Core\Config\ConfigFactoryInterface;

use Drupal\ldap_servers\Entity\Server;
use Drupal\ldap_user\LdapUserConf;
use Drupal\ldap_user\SemaphoreStorage;

/**
 *
 */
class LdapUserAdminForm extends ConfigFormBase {

  protected $LdapUserConfHelper;

  protected $drupalAcctProvisionServerOptions;
  protected $ldapEntryProvisionServerOptions;

  /**
   * {@inheritdoc}
   */
  public function __construct(ConfigFactoryInterface $config_factory) {
    parent::__construct($config_factory);

    $this->LdapUserConfHelper = new LdapUserConf();
    $factory = \Drupal::service('ldap.servers');
    $ldap_servers = $factory->getEnabledServers();
    if ($ldap_servers) {
      foreach ($ldap_servers as $sid => $ldap_server) {
        /* @var Server $ldap_server */
        $enabled = ($ldap_server->get('status')) ? 'Enabled' : 'Disabled';
        $this->drupalAcctProvisionServerOptions[$sid] = $ldap_server->label() . ' (' . $ldap_server->get('address') . ') Status: ' . $enabled;
        $this->ldapEntryProvisionServerOptions[$sid] = $ldap_server->label() . ' (' . $ldap_server->get('address') . ') Status: ' . $enabled;
      }
    }
    $this->drupalAcctProvisionServerOptions['none'] = t('None');
    $this->ldapEntryProvisionServerOptions['none'] = t('None');
  }

  /**
   * {@inheritdoc}
   */
  public function getFormId() {
    return 'ldap_user_admin_form';
  }

  /**
   * {@inheritdoc}
   */
  public function getEditableConfigNames() {
    return ['ldap_user.settings'];
  }

  /**
   * {@inheritdoc}
   */
  public function buildForm(array $form, FormStateInterface $form_state) {
    $config = $this->config('ldap_user.settings');

    if (count($this->drupalAcctProvisionServerOptions) == 0) {
      $url = Url::fromRoute('entity.ldap_server.collection');
      $edit_server_link = \Drupal::l(t('@path', array('@path' => 'LDAP Servers')), $url);
      $message = t('At least one LDAP server must configured and <em>enabled</em>
 before configuring LDAP user. Please go to @link to configure an LDAP server.',
        ['@link' => $edit_server_link]
      );
      $form['intro'] = array(
        '#type' => 'item',
        '#markup' => t('<h1>LDAP User Settings</h1>') . $message,
      );
      return $form;
    }
    $form['#storage'] = array();

    $form['intro'] = array(
      '#type' => 'item',
      '#markup' => t('<h1>LDAP User Settings</h1>'),
    );

    $form['manual_drupal_account_editing'] = array(
      '#type' => 'fieldset',
      '#title' => t('Manual Drupal Account Creation and Updates'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    $form['manual_drupal_account_editing']['manualAccountConflict'] = array(
      '#type' => 'radios',
      '#options' => array(
        LdapUserConf::$manualAccountConflictReject => t('Reject manual creation of Drupal accounts that conflict with LDAP Accounts. This only applies to accounts created on user logon;  Account conflicts can still be generated by manually creating users that conflict with ldap users and these users will have their data synced with LDAP data.'),
        LdapUserConf::$manualAccountConflictLdapAssociate => t('Associate manually created Drupal accounts with related LDAP Account if one exists.'),
        LdapUserConf::$manualAccountConflictShowOptionOnForm => t('Show option on user create form to determine how account conflict is resolved.'),
      ),
      '#title' => t('How to resolve LDAP conflicts with manually  created Drupal accounts.'),
      '#description' => t('This applies only to accounts created manually through admin/people/create for which an LDAP entry can be found on the LDAP server selected in "LDAP Servers Providing Provisioning Data"'),
      '#default_value' => $config->get('ldap_user_conf.manualAccountConflict'),
    );

    $form['basic_to_drupal'] = array(
      '#type' => 'fieldset',
      '#title' => t('Basic Provisioning to Drupal Account Settings'),
      '#collapsible' => TRUE,
      '#collapsed' => !($config->get('ldap_user_conf.drupalAcctProvisionServer')),
    );

    $form['basic_to_drupal']['drupalAcctProvisionServer'] = array(
      '#type' => 'radios',
      '#title' => t('LDAP Servers Providing Provisioning Data'),
      '#required' => 1,
      '#default_value' => $config->get('ldap_user_conf.drupalAcctProvisionServer'),
      '#options' => $this->drupalAcctProvisionServerOptions,
      '#description' => t('Choose the LDAP server configuration to use in provisioning Drupal users and their user fields.'),
      '#states' => array(
        // Action to take.
        'enabled' => array(
          ':input[name=drupalAcctProvisionTriggers]' => array('value' => LdapUserConf::$provisionDrupalUserOnAuthentication),
        ),
      ),
    );

    $form['basic_to_drupal']['drupalAcctProvisionTriggers'] = [
      '#type' => 'checkboxes',
      '#title' => t('Drupal Account Provisioning Events'),
      '#required' => FALSE,
      '#default_value' => $config->get('ldap_user_conf.drupalAcctProvisionTriggers'),
      '#options' => [
        LdapUserConf::$provisionDrupalUserOnAuthentication => t('Create or Sync to Drupal user on successful authentication with LDAP credentials. (Requires LDAP Authentication module).'),
        LdapUserConf::$provisionDrupalUserOnUserUpdateCreate => t('Create or Sync to Drupal user anytime a Drupal user account is created or updated. Requires a server with binding method of "Service Account Bind" or "Anonymous Bind".'),
      ],
      '#description' => t('Which user fields and properties are synced on create or sync is determined in the "Provisioning from LDAP to Drupal mappings" table below in the right two columns.'),
    ];

    $form['basic_to_drupal']['userConflictResolve'] = array(
      '#type' => 'radios',
      '#title' => t('Existing Drupal User Account Conflict'),
      '#required' => 1,
      '#default_value' => $config->get('ldap_user_conf.userConflictResolve'),
      '#options' => [
        LdapUserConf::$userConflictLog => t('Don\'t associate Drupal account with LDAP.  Require user to use Drupal password. Log the conflict'),
        LdapUserConf::$userConflictAttemptResolve => t('Associate Drupal account with the LDAP entry.  This option is useful for creating accounts and assigning roles before an LDAP user authenticates.'),
      ],
      '#description' => t('What should be done if a local Drupal or other external user account already exists with the same login name.'),
    );

    $form['basic_to_drupal']['acctCreation'] = array(
      '#type' => 'radios',
      '#title' => t('Application of Drupal Account settings to LDAP Authenticated Users'),
      '#required' => 1,
      '#default_value' => $config->get('ldap_user_conf.acctCreation'),
      '#options' => [
        LdapUserConf::$accountCreationLdapBehaviour => t('Account creation settings at /admin/config/people/accounts/settings do not affect "LDAP Associated" Drupal accounts.'),
        LdapUserConf::$accountCreationUserSettingsForLdap => t('Account creation policy at /admin/config/people/accounts/settings applies to both Drupal and LDAP Authenticated users. "Visitors" option automatically creates and account when they successfully LDAP authenticate. "Admin" and "Admin with approval" do not allow user to authenticate until the account is approved.'),

      ],
    );

    $account_options = array();
    $account_options['ldap_user_orphan_do_not_check'] = t('Do not check for orphaned Drupal accounts.');
    $account_options['ldap_user_orphan_email'] = t('Perform no action, but email list of orphaned accounts. (All the other options will send email summaries also.)');
    foreach (user_cancel_methods()['#options'] as $option_name => $option_title) {
      $account_options[$option_name] = $option_title;
    }

    // @todo these 2 options are removed until this feature is better tested in
    // actual production environments; it has potentially disastrous effects
    unset($account_options['user_cancel_reassign']);
    unset($account_options['user_cancel_delete']);

    $form['basic_to_drupal']['orphanedDrupalAcctBehavior'] = array(
      '#type' => 'radios',
      '#title' => t('Action to perform on Drupal accounts that no longer have
        corresponding LDAP entries'),
      '#required' => 0,
      // @FIX ME
      '#default_value' => $config->get('ldap_user_conf.orphanedDrupalAcctBehavior'),
      '#options' => $account_options,
      '#description' => t('It is highly recommended to use the "Perform no action, but email list of orphaned accounts" for some time before using the "Disable the account" options. <br>
         These actions will only occur if the query to the erver is successful and does not return a user entry.'),
    );

    $form['basic_to_drupal']['orphanedCheckQty'] = array(
      '#type' => 'textfield',
      '#size' => 10,
      '#title' => t('Number of users to check each cron run.'),
      '#description' => t(''),
      '#default_value' => $config->get('ldap_user_conf.orphanedCheckQty'),
      '#required' => FALSE,
    );

    $form['basic_to_ldap'] = array(
      '#type' => 'fieldset',
      '#title' => t('Basic Provisioning to LDAP Settings'),
      '#collapsible' => TRUE,
      '#collapsed' => !($config->get('ldap_user_conf.ldapEntryProvisionServer')),
    );

    $form['basic_to_ldap']['ldapEntryProvisionServer'] = array(
      '#type' => 'radios',
      '#title' => t('LDAP Servers to Provision LDAP Entries on'),
      '#required' => 1,
      '#default_value' => $config->get('ldap_user_conf.ldapEntryProvisionServer'),
      '#options' => $this->ldapEntryProvisionServerOptions,
      '#description' => t('Check ONE LDAP server configuration to create LDAP entries on.'),
    );

    $form['basic_to_ldap']['ldapEntryProvisionTriggers'] = array(
      '#type' => 'checkboxes',
      '#title' => t('LDAP Entry Provisioning Events'),
      '#required' => FALSE,
      '#default_value' => $config->get('ldap_user_conf.ldapEntryProvisionTriggers'),
      '#options' => array(
        LdapUserConf::$provisionLdapEntryOnUserUpdateCreate => t('Create or Sync to LDAP entry when a Drupal account is created or updated.
        Only applied to accounts with a status of approved.'),
        LdapUserConf::$provisionLdapEntryOnUserAuthentication => t('Create or Sync to LDAP entry when a user authenticates.'),
        LdapUserConf::$provisionLdapEntryOnUserDelete => t('Delete LDAP entry when the corresponding Drupal Account is deleted.  This only applies when the LDAP entry was provisioned by Drupal by the LDAP User module.'),
        LdapUserConf::$provisionDrupalUserOnAllowingManualCreation => t('Provide option on admin/people/create to create corresponding LDAP Entry.'),

      ),
      '#description' => t('Which LDAP attributes are synced on create or sync is determined in the
      "Provisioning from Drupal to LDAP mappings" table below in the right two columns.'),
    );

    $form['server_mapping_preamble'] = array(
      '#type' => 'markup',
      '#markup' => t('
The relationship between a Drupal user and an LDAP entry is defined within the LDAP server configurations.


The mappings below are for user fields, properties, and profile2 data that are not automatically mapped elsewhere.
Mappings such as username or email address that are configured elsewhere are shown at the top for clarity.
When more than one ldap server is enabled for provisioning data (or simply more than one configuration for the same ldap server),
mappings need to be setup for each server.  If no tables are listed below, you have not enabled any provisioning servers at
the top of this form.
'),

    );

    foreach (array(LdapUserConf::$provisioningDirectionToDrupalUser, LdapUserConf::$provisioningDirectionToLDAPEntry) as $direction) {

      if ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) {
        $parent_fieldset = 'basic_to_drupal';
        $description = t('Provisioning from LDAP to Drupal Mappings:');
      }
      elseif ($direction == LdapUserConf::$provisioningDirectionToLDAPEntry) {
        $parent_fieldset = 'basic_to_ldap';
        $description = t('Provisioning from Drupal to LDAP Mappings:');
      }

      $mapping_id = 'mappings__' . $direction;
      $table_id = $mapping_id . '__table';

      $form[$parent_fieldset][$mapping_id] = [
        '#type' => 'fieldset',
        '#title' => $description,
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
        '#description' => t('See also the <a href="@wiki_link">Drupal.org wiki page</a> for further information on using LDAP tokens.',
          ['@wiki_link' => 'http://drupal.org/node/1245736']),
      ];

      $form[$parent_fieldset][$mapping_id][$table_id] = [
        '#type' => 'table',
        '#header' => [t('Label'), t('Machine name'), t('Weight'), t('Operations')],
        '#attributes' => ['class' => ['mappings-table']],
      ];

      $headers = $this->getServerMappingHeader($direction);
      $form[$parent_fieldset][$mapping_id][$table_id]['#header'] = $headers['header'];
      // Add in the second header as the first row.
      $form[$parent_fieldset][$mapping_id][$table_id]['second-header'] = array(
        '#attributes' => array('class' => 'header'),
      );
      // Second header uses the same format as header.
      foreach ($headers['second_header'] as $cell) {
        $form[$parent_fieldset][$mapping_id][$table_id]['second-header'][] = array(
          '#title' => $cell['data'],
          '#type' => 'item',
        );
        if (isset($cell['class'])) {
          $form[$parent_fieldset][$mapping_id][$table_id]['second-header']['#attributes'] = array('class' => array($cell['class']));
        }
        if (isset($cell['rowspan'])) {
          $form[$parent_fieldset][$mapping_id][$table_id]['second-header']['#rowspan'] = $cell['rowspan'];
        }
        if (isset($cell['colspan'])) {
          $form[$parent_fieldset][$mapping_id][$table_id]['second-header']['#colspan'] = $cell['colspan'];
        }
      }

      // Add in all the mappings. @TODO fix the save handlers.
      $form[$parent_fieldset][$mapping_id][$table_id] += $this->getServerMappingFields($direction);

      $password_notes = '<h3>' . t('Password Tokens') . '</h3><ul>' .
        '<li>' . t('Pwd: Random -- Uses a random Drupal generated password') . '</li>' .
        '<li>' . t('Pwd: User or Random -- Uses password supplied on user forms.
  If none available uses random password.') . '</li></ul>' .
        '<h3>' . t('Password Concerns') . '</h3>' .
        '<ul>' .
        '<li>' . t('Provisioning passwords to LDAP means passwords must meet the LDAP\'s
password requirements.  Password Policy module can be used to add requirements.') . '</li>' .
        '<li>' . t('Some LDAPs require a user to reset their password if it has been changed
by someone other that user.  Consider this when provisioning LDAP passwords.') . '</li>' .
        '</ul></p>';

      $source_drupal_token_notes = <<<EOT
<p>Examples in form: Source Drupal User token => Target LDAP Token (notes)</p>
<ul>
<li>Source Drupal User token => Target LDAP Token</li>
<li>cn=[property.name],ou=test,dc=ad,dc=mycollege,dc=edu => [dn] (example of token and constants)</li>
<li>top => [objectclass:0] (example of constants mapped to multivalued attribute)</li>
<li>person => [objectclass:1] (example of constants mapped to multivalued attribute)</li>
<li>organizationalPerson => [objectclass:2] (example of constants mapped to multivalued attribute)</li>
<li>user => [objectclass:3] (example of constants mapped to multivalued attribute)</li>
<li>Drupal Provisioned LDAP Account => [description] (example of constant)</li>
<li>[field.field_lname] => [sn]</li>

</ul>
EOT;

      // Add some password notes.
      if ($direction == LdapUserConf::$provisioningDirectionToLDAPEntry) {
        $form[$parent_fieldset]['password_notes'] = array(
          '#type' => 'fieldset',
          '#title' => t('Password Notes'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          'directions' => array(
            '#type' => 'markup',
            '#markup' => $password_notes,
          ),
        );
        $form[$parent_fieldset]['source_drupal_token_notes'] = array(
          '#type' => 'fieldset',
          '#title' => t('Source Drupal User Tokens and Corresponding Target LDAP Tokens'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          'directions' => array(
            '#type' => 'markup',
            '#markup' => $source_drupal_token_notes,
          ),
        );
      }
    }

    foreach (array('orphanedCheckQty', 'orphanedDrupalAcctBehavior', 'acctCreation', 'userConflictResolve', 'drupalAcctProvisionTriggers', 'mappings__' . LdapUserConf::$provisioningDirectionToDrupalUser) as $input_name) {
      $form['basic_to_drupal'][$input_name]['#states']['invisible'] =
        array(
          ':input[name=drupalAcctProvisionServer]' => array('value' => 'none'),
        );
    }

    foreach (array('ldapEntryProvisionTriggers', 'password_notes', 'source_drupal_token_notes', 'mappings__' . LdapUserConf::$provisioningDirectionToLDAPEntry) as $input_name) {
      $form['basic_to_ldap'][$input_name]['#states']['invisible'] =
        array(
          ':input[name=ldapEntryProvisionServer]' => array('value' => 'none'),
        );
    }

    $form['actions']['#type'] = 'actions';
    $form['actions']['submit'] = array(
      '#type' => 'submit',
      '#value' => 'Save',
    );

    // @FIXME: Determine what is still needed here from this function.
    // In theory this should also be called on validateForm. Not ideal, investigate.
    // $this->validateCurrentConfiguration($form);
    return $form;
  }

  /**
   * {@inheritdoc}
   */
  public function validateForm(array &$form, FormStateInterface $form_state) {

    // @FIXME: Moved over from LdapUserConfAdmin for obvious reasons.
    // @TODO these form fields aren't named like this anymore
    // since failed mapping rows in form, don't populate ->ldapUserSyncMappings, need to validate these from values
    foreach ($form_state->getValues() as $field => $value) {
      $parts = explode('__', $field);
      // Since sync mapping fields are in n-tuples, process entire n-tuple at once (on field == configurable_to_drupal)
      if (count($parts) != 4 || $parts[1] !== 'sm' || $parts[2] != 'configurable_to_drupal') {
        continue;
      }
      list($direction, $discard, $column_name, $i) = $parts;
      // $action = $storage['sync_mapping_fields'][$direction][$i]['action'];.
      $tokens = array();
      $row_mappings = array();
      foreach (array(
        'remove',
        'configurable_to_drupal',
        'configurable_to_ldap',
        'convert',
        'direction',
        'ldap_attr',
        'user_attr',
        'user_tokens',
      ) as $column_name) {
        $input_name = join('__', array('sm', $column_name, $i));
        $row_mappings[$column_name] = isset($values[$input_name]) ? $values[$input_name] : NULL;
      }

      $has_values = $row_mappings['ldap_attr'] || $row_mappings['user_attr'];
      if ($has_values) {
        $tokens['%ldap_attr'] = $row_mappings['ldap_attr'];
        $row_descriptor = t("server %sid row mapping to ldap attribute %ldap_attr", $tokens);
        $tokens['!row_descriptor'] = $row_descriptor;
        if (!$row_mappings['direction']) {
          $input_name = join('__', array('sm', 'direction', $i));
          $errors[$input_name] = t('No mapping direction given in !row_descriptor', $tokens);
        }
        if ($direction == LdapUserConf::$provisioningDirectionToDrupalUser && $row_mappings['user_attr'] == 'user_tokens') {
          $input_name = join('__', array('sm', 'user_attr', $i));
          $errors[$input_name] = t('User tokens not allowed when mapping to Drupal user.  Location: !row_descriptor', $tokens);
        }
        if (!$row_mappings['ldap_attr']) {
          $input_name = join('__', array('sm', 'ldap_attr', $i));
          $errors[$input_name] = t('No ldap attribute given in !row_descriptor', $tokens);
        }
        if (!$row_mappings['user_attr']) {
          $input_name = join('__', array('sm', 'user_attr', $i));
          $errors[$input_name] = t('No user attribute given in !row_descriptor', $tokens);
        }
      }

    }

  }

  /**
   * {@inheritdoc}
   */
  public function submitForm(array &$form, FormStateInterface $form_state) {

    /**
     * Recheck these
     * $this->drupalAcctProvisionServer = ($values['drupalAcctProvisionServer'] == 'none') ? 0 : $values['drupalAcctProvisionServer'];
     * $this->ldapEntryProvisionServer = ($values['ldapEntryProvisionServer'] == 'none') ? 0 : $values['ldapEntryProvisionServer'];
     * $this->userConflictResolve  = ($values['userConflictResolve']) ? (int) $values['userConflictResolve'] : NULL;
     */

    $processedSyncMappings = $this->syncMappingsFromForm($form_state->getValues());

    $this->config('ldap_user.settings')
      ->set('ldap_user_conf.drupalAcctProvisionServer', $form_state->getValue('drupalAcctProvisionServer'))
      ->set('ldap_user_conf.ldapEntryProvisionServer', $form_state->getValue('ldapEntryProvisionServer'))
      ->set('ldap_user_conf.drupalAcctProvisionTriggers', $form_state->getValue('drupalAcctProvisionTriggers'))
      ->set('ldap_user_conf.ldapEntryProvisionTriggers', $form_state->getValue('ldapEntryProvisionTriggers'))
      ->set('ldap_user_conf.orphanedDrupalAcctBehavior', $form_state->getValue('orphanedDrupalAcctBehavior'))
      ->set('ldap_user_conf.orphanedCheckQty', $form_state->getValue('orphanedCheckQty'))
      ->set('ldap_user_conf.userConflictResolve', $form_state->getValue('userConflictResolve'))
      ->set('ldap_user_conf.manualAccountConflict', $form_state->getValue('manualAccountConflict'))
      ->set('ldap_user_conf.acctCreation', $form_state->getValue('acctCreation'))
      ->set('ldap_user_conf.ldapUserSyncMappings', $processedSyncMappings)
      ->save();
    $form_state->getValues();

    SemaphoreStorage::flushAllValues();
  }

  /**
   * Migrated from ldap_user.theme.inc .
   */
  private function getServerMappingHeader($direction) {

    if ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) {

      $direction_text = 'todrupal';

      $header = [
        [
          'data' => t('Remove'),
          'rowspan' => 1,
        ],
        [
          'data' => t('Source LDAP tokens') ,
          'rowspan' => 1,
          'colspan' => 2,
        ],
        [
          'data' => t('Target Drupal attribute'),
          'rowspan' => 1,
        ],
        [
          'data' => t('Synchronization event'),
          'colspan' => count($this->LdapUserConfHelper->provisionsDrupalEvents),
          'rowspan' => 1,
        ],

      ];

      $second_header = [
        [
          'data' => '',
          'header' => TRUE,
        ],
        [
          'data' => t('Examples:<ul><li>[sn]</li><li>[mail:0]</li><li>[ou:last]</li><li>[sn], [givenName]</li></ul>
                Constants such as <em>17</em> or <em>imported</em> should not be enclosed in [].'),
          'header' => TRUE,
        ],
        [
          'data' => t('Convert from binary'),
          'header' => TRUE,
        ],
        [
          'data' => '',
          'header' => TRUE,
        ],
      ];

      foreach ($this->LdapUserConfHelper->provisionsDrupalEvents as $col_id => $col_name) {
        $second_header[] = array('data' => $col_name, 'header' => TRUE, 'class' => 'header-provisioning');
      }
    }
    // To ldap.
    else {

      $direction_text = 'toldap';

      $header = [
        [
          'data' => t('Remove'),
          'rowspan' => 1,
        ],
        [
          'data' => t('Source Drupal user attribute') ,
          'rowspan' => 1,
          'colspan' => 3,
        ],
        [
          'data' => t('Target LDAP token'),
          'rowspan' => 1,
        ],
        [
          'data' => t('Synchronization event'),
          'colspan' => count($this->LdapUserConfHelper->provisionsLdapEvents),
          'rowspan' => 1,
        ],
      ];

      $second_header = [
        [
          'data' => '',
          'header' => TRUE,
        ],
        [
          'data' => t('Note: Select <em>user tokens</em> to use token field.'),
          'header' => TRUE,
        ],
        [
          'data' => t('Source Drupal user tokens such as: <ul><li>[property.name]</li><li>[field.field_fname]</li><li>[field.field_lname]</li></ul> Constants such as <em>from_drupal</em> or <em>18</em> should not be enclosed in [].'),
          'header' => TRUE,
        ],
        [
          'data' => t('Convert From binary'),
          'header' => TRUE,
        ],
        [
          'data' => t('Use singular token format such as: <ul><li>[sn]</li><li>[givenName]</li></ul>'),
          'header' => TRUE,
        ],
      ];
      foreach ($this->LdapUserConfHelper->provisionsLdapEvents as $col_id => $col_name) {
        $second_header[] = array('data' => $col_name, 'header' => TRUE, 'class' => 'header-provisioning');
      }
    }
    return ['header' => $header, 'second_header' => $second_header];
  }

  /**
   *
   */
  private function getServerMappingFields($direction) {
    if ($direction == LdapUserConf::$provisioningDirectionNone) {
      return;
    }

    $rows = array();

    $text = ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) ? 'target' : 'source';
    $user_attr_options = array('0' => t('Select') . ' ' . $text);

    if (!empty($this->LdapUserConfHelper->syncMapping[$direction])) {
      foreach ($this->LdapUserConfHelper->syncMapping[$direction] as $target_id => $mapping) {

        if (!isset($mapping['name']) || isset($mapping['exclude_from_mapping_ui']) && $mapping['exclude_from_mapping_ui']) {
          continue;
        }
        if (
          (isset($mapping['configurable_to_drupal']) && $mapping['configurable_to_drupal'] && $direction == LdapUserConf::$provisioningDirectionToDrupalUser)
          ||
          (isset($mapping['configurable_to_ldap']) && $mapping['configurable_to_ldap']  && $direction == LdapUserConf::$provisioningDirectionToLDAPEntry)
        ) {
          $user_attr_options[$target_id] = substr($mapping['name'], 0, 25);
        }
      }
    }
    $user_attr_options['user_tokens'] = '-- user tokens --';

    $row = 0;

    // 1. non configurable mapping rows.
    foreach ($this->LdapUserConfHelper->syncMapping[$direction] as $target_id => $mapping) {
      $row_id = $this->sanitise_machine_name($target_id);
      if (isset($mapping['exclude_from_mapping_ui']) && $mapping['exclude_from_mapping_ui']) {
        continue;
      }
      // Is configurable by ldap_user module (not direction to ldap_user)
      if (!$this->isMappingConfigurable($mapping, 'ldap_user') && ($mapping['direction'] == $direction || $mapping['direction'] == LdapUserConf::$provisioningDirectionAll)) {
        $rows[$row_id] = $this->getSyncFormRow('nonconfigurable', $direction, $mapping, $user_attr_options, $row_id);
        $row++;
      }
    }
    $config = $this->config('ldap_user.settings');

    // 2. existing configurable mappings rows.
    if (!empty($config->get('ldap_user_conf.ldapUserSyncMappings')[$direction])) {
      // Key could be ldap attribute name or user attribute name.
      foreach ($config->get('ldap_user_conf.ldapUserSyncMappings')[$direction] as $target_attr_token => $mapping) {
        if (isset($mapping['enabled']) && $mapping['enabled'] && $this->isMappingConfigurable($this->LdapUserConfHelper->syncMapping[$direction][$mapping['user_attr']], 'ldap_user')) {
          $row_id = 'row-' . $row;
          $rows[$row_id] = $this->getSyncFormRow('update', $direction, $mapping, $user_attr_options, $row_id);
          $row++;
        }
      }
    }

    // 3. leave 4 rows for adding more mappings.
    for ($i = 0; $i < 4; $i++) {
      $row_id = 'custom-' . $i;
      $rows[$row_id] = $this->getSyncFormRow('add', $direction, NULL, $user_attr_options, $row_id);
      $row++;
    }

    return $rows;
  }

  /**
   * Get mapping form row to ldap user provisioning mapping admin form table.
   *
   * @param drupal form array $form
   * @param string $action
   *   is 'add', 'update', or 'nonconfigurable'.
   * @param string $direction
   *   LdapUserConf::$provisioningDirectionToDrupalUser or LdapUserConf::$provisioningDirectionToLDAPEntry.
   * @param array $mapping
   *   is current setting for updates or nonconfigurable items.
   * @param array $user_attr_options
   *   of drupal user target options.
   * @param int $row
   *   is current row in table.
   *
   * @return array
   *   A single row
   */
  private function getSyncFormRow($action, $direction, $mapping, $user_attr_options, $row_id) {

    $result = array();
    $id_prefix = 'mappings__' . $direction . '__table';
    $user_attr_input_id = $id_prefix . "[$row_id][user_attr]";

    $result['remove'] = array(
      '#type' => 'checkbox',
      '#title' => 'Remove',
      '#title_display' => 'invisible',
      '#default_value' => NULL,
      '#disabled' => ($action == 'add' || $action == 'nonconfigurable'),
    );

    if ($action == 'nonconfigurable') {
      $ldap_attr = array(
        '#type' => 'item',
        '#default_value' => isset($mapping['ldap_attr']) ? $mapping['ldap_attr'] : '',
        '#markup' => isset($mapping['source']) ? $mapping['source'] : '?',
        '#attributes' => array('class' => array('source')),
      );
    }
    else {
      $ldap_attr = array(
        '#type' => 'textfield',
        '#title' => 'LDAP attribute',
        '#title_display' => 'invisible',
        '#default_value' => isset($mapping['ldap_attr']) ? $mapping['ldap_attr'] : '',
        '#size' => 20,
        '#maxlength' => 255,
        '#attributes' => array('class' => array('ldap-attr')),
      );
      // Change the visibility rules for LdapUserConf::$provisioningDirectionToLDAPEntry.
      if ($direction == LdapUserConf::$provisioningDirectionToLDAPEntry) {
        $user_tokens = array(
          '#type' => 'textfield',
          '#title' => 'User tokens',
          '#title_display' => 'invisible',
          '#default_value' => isset($mapping['user_tokens']) ? $mapping['user_tokens'] : '',
          '#size' => 20,
          '#maxlength' => 255,
          '#disabled' => ($action == 'nonconfigurable'),
          '#attributes' => array('class' => array('tokens')),
        );

        $user_tokens['#states'] = array(
          'visible' => array(
            'select[name="' . $user_attr_input_id . '"]' => array('value' => 'user_tokens'),
          ),
        );
      }
    }

    $convert = array(
      '#type' => 'checkbox',
      '#title' => 'Convert from binary',
      '#title_display' => 'invisible',
      '#default_value' => isset($mapping['convert']) ? $mapping['convert'] : '',
      '#disabled' => ($action == 'nonconfigurable'),
      '#attributes' => array('class' => array('convert')),
    );

    if ($action == 'nonconfigurable') {
      $user_attr = array(
        '#type' => 'item',
        '#markup' => isset($mapping['name']) ? $mapping['name'] : '?',
      );
    }
    else {
      $user_attr = array(
        '#type' => 'select',
        '#title' => 'User attribute',
        '#title_display' => 'invisible',
        '#default_value' => isset($mapping['user_attr']) ? $mapping['user_attr'] : '',
        '#options' => $user_attr_options,
      );
    }

    // Get the order of the columns correctly.
    if ($direction == LdapUserConf::$provisioningDirectionToLDAPEntry) {
      $result['user_attr'] = $user_attr;
      $result['user_tokens'] = $user_tokens;
      $result['convert'] = $convert;
      $result['ldap_attr'] = $ldap_attr;
    }
    else {
      $result['ldap_attr'] = $ldap_attr;
      $result['convert'] = $convert;
      $result['user_attr'] = $user_attr;
    }

    $result['#storage']['sync_mapping_fields'][$direction] = array(
      'action' => $action,
      'direction' => $direction,
    );
    // FIXME: Add table selection / ordering back:
    // $col and $row used to be paremeters to $result[$prov_event]. ID possible
    // not need needed anymore. Row used to be a parameter to this function.
    // $col = ($direction == LdapUserConf::$provisioningDirectionToLDAPEntry) ? 5 : 4;.
    $syncEvents = ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) ? $this->LdapUserConfHelper->provisionsDrupalEvents : $this->LdapUserConfHelper->provisionsLdapEvents;

    foreach ($syncEvents as $prov_event => $prov_event_name) {
      // See above.
      // $col++;
      // $id = $id_prefix . join('__', array('sm', $prov_event, $row));.
      $result[$prov_event] = array(
        '#type' => 'checkbox',
        '#title' => $prov_event,
        '#title_display' => 'invisible',
        '#default_value' => isset($mapping['prov_events']) ? (int) (in_array($prov_event, $mapping['prov_events'])) : '',
        '#disabled' => (!$this->provisionEventConfigurable($prov_event, $mapping) || ($action == 'nonconfigurable')),
        '#attributes' => array('class' => array('sync-method')),
      );
    }

    // This one causes the extra column.
    $result['configurable_to_drupal'] = array(
      '#type' => 'hidden',
      '#default_value' => ($action != 'nonconfigurable' ? 1 : 0),
      '#class' => '',
    );

    return $result;
  }

  /**
   * Is a mapping configurable by a given module?
   *
   * @param array $mapping
   *   as mapping configuration for field, attribute, property, etc.
   * @param string $module
   *   machine name such as ldap_user.
   *
   * @return bool
   */
  private function isMappingConfigurable($mapping = NULL, $module = 'ldap_user') {
    $configurable = (
      (
        (!isset($mapping['configurable_to_drupal']) && !isset($mapping['configurable_to_ldap'])) ||
        (isset($mapping['configurable_to_drupal']) && $mapping['configurable_to_drupal']) ||
        (isset($mapping['configurable_to_ldap']) && $mapping['configurable_to_ldap'])
      )
      &&
      (
        !isset($mapping['config_module']) ||
        (isset($mapping['config_module']) && $mapping['config_module'] == $module)
      )
    );
    return $configurable;
  }

  /**
   * Is a particular sync method viable for a given mapping?
   * That is, Can it be enabled in the UI by admins?
   *
   * @param int $prov_event
   * @param array $mapping
   *   is array of mapping configuration.
   *
   * @return bool
   */
  private function provisionEventConfigurable($prov_event, $mapping = NULL) {

    $configurable = FALSE;

    if ($mapping) {
      if ($prov_event == LdapUserConf::$eventCreateLdapEntry || $prov_event == LdapUserConf::$eventSyncToLdapEntry) {
        $configurable = (boolean) (!isset($mapping['configurable_to_ldap']) || $mapping['configurable_to_ldap']);
      }
      elseif ($prov_event == LdapUserConf::$eventCreateDrupalUser || $prov_event == LdapUserConf::$eventSyncToDrupalUser) {
        $configurable = (boolean) (!isset($mapping['configurable_to_drupal']) || $mapping['configurable_to_drupal']);
      }
    }
    else {
      $configurable = TRUE;
    }

    return $configurable;
  }

  /**
   * Returns a config compatible machine name.
   */
  private function sanitise_machine_name($string) {
    // Replace dots
    // Replace square brackets.
    return str_replace(['.', '[', ']'], ['-', '', ''], $string);
  }

  /**
   * Extract sync mappings array from mapping table in admin form.
   *
   * @param array $values
   *   as $form_state['values'] from drupal form api.
   * @param array $storage
   *   as $form_state['storage'] from drupal form api
   *
   *   WARNING: Rewritten using nested forms. This may no longer apply.
   *
   *   $values input names in form:
   *   1__sm__configurable__5,
   *   1__sm__remove__5,
   *   1__sm__ldap_attr__5,
   *   1__sm__convert__5,
   *   1__sm__direction__5,
   *   1__sm__user_attr__5,
   *   1__sm__user_tokens__5
   *   1__sm__1__5,
   *   1__sm__2__5,
   *   ...where
   *    -- first arg is direction, eg 1 or 2 LdapUserConf::$provisioningDirectionToDrupalUser or LdapUserConf::$provisioningDirectionToLDAPEntry
   *    -- second arg is discarded ('sm')
   *    -- third part is field, e.g. user_attr
   *    -- fourth is the row in the configuration form, e.g. 5
   *
   *   where additiond data is in $form['#storage'][<direction>]['sync_mapping_fields'][N]
   *   $form['#storage']['sync_mapping_fields'][<direction>][N] = array(
   *    'sid' => $sid,
   *    'action' => 'add',
   *   );.
   *
   * @return array
   *   Returns the relevant mappings.
   */
  private function syncMappingsFromForm($values) {
    $mappings = array();
    foreach ($values as $field_name => $value) {

      $parts = explode('__', $field_name);
      if ($parts[0] != 'mappings') {
        continue;
      }
      $direction = $parts[1];

      // These are our rows.
      foreach ($value as $row_descriptor => $columns) {
        if ($row_descriptor == 'second-header') {
          continue;
        }

        $key = ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) ? $this->sanitise_machine_name($columns['user_attr']) : $this->sanitise_machine_name($columns['ldap_attr']);
        // Only save if its configurable and has an ldap and drupal attributes. The others are optional.
        if ($columns['configurable_to_drupal'] && $columns['ldap_attr'] && $columns['user_attr']) {
          $mappings[$direction][$key] = array(
            'ldap_attr'   => $columns['ldap_attr'],
            'user_attr'   => $columns['user_attr'],
            'convert'     => $columns['convert'],
            'direction'   => $direction,
           // @FIXME: user_tokens is missing
           // 'user_tokens' => $columns['user_tokens'],
            'config_module' => 'ldap_user',
            'prov_module' => 'ldap_user',
            'enabled'     => 1,
          );

          $syncEvents = ($direction == LdapUserConf::$provisioningDirectionToDrupalUser) ? $this->LdapUserConfHelper->provisionsDrupalEvents : $this->LdapUserConfHelper->provisionsLdapEvents;
          foreach ($syncEvents as $prov_event => $discard) {
            if (isset($columns[$prov_event]) && $columns[$prov_event]) {
              $mappings[$direction][$key]['prov_events'][] = $prov_event;
            }
          }
        }
      }
    }
    return $mappings;
  }

  /**
   * Validate object, not form.
   *
   * @param array $values
   *   as $form_state['values'] from drupal form api.
   *
   * @return array in form array($errors, $warnings)to be thrown by form api
   *
   * @todo validate that a user field exists, such as field.field_user_lname
   */
  private function validateCurrentConfiguration($values) {
    $errors = array();
    $warnings = array();
    $tokens = array();
    $has_drupal_acct_prov_servers = FALSE;

    if (\Drupal::config('ldap_user.settings')->get('ldap_user_conf.drupalAcctProvisionServer')) {
      $has_drupal_acct_prov_servers = TRUE;
    };

    $has_drupal_acct_prov_settings_options  = (count(array_filter(\Drupal::config('ldap_user.settings')->get('ldap_user_conf.drupalAcctProvisionTriggers'))) > 0);

    if (!$has_drupal_acct_prov_servers && $has_drupal_acct_prov_settings_options) {
      $warnings['drupalAcctProvisionServer'] = t('No Servers are enabled to provide provisioning to Drupal, but Drupal Account Provisioning Options are selected.', $tokens);
    }
    if ($has_drupal_acct_prov_servers && !$has_drupal_acct_prov_settings_options) {
      $warnings['drupalAcctProvisionTriggers'] = t('Servers are enabled to provide provisioning to Drupal, but no Drupal Account Provisioning Options are selected.  This will result in no syncing happening.', $tokens);
    }

    $has_ldap_prov_servers = FALSE;
    if (\Drupal::config('ldap_user.settings')->get('ldap_user_conf.ldapEntryProvisionServer')) {
      $has_ldap_prov_servers = TRUE;
    };

    $has_ldap_prov_settings_options = (count(array_filter(\Drupal::config('ldap_user.settings')->get('ldap_user_conf.ldapEntryProvisionTriggers'))) > 0);
    if (!$has_ldap_prov_servers && $has_ldap_prov_settings_options) {
      $warnings['ldapEntryProvisionServer'] = t('No Servers are enabled to provide provisioning to ldap, but LDAP Entry Options are selected.', $tokens);
    }
    if ($has_ldap_prov_servers && !$has_ldap_prov_settings_options) {
      $warnings['ldapEntryProvisionTriggers'] = t('Servers are enabled to provide provisioning to ldap, but no LDAP Entry Options are selected.  This will result in no syncing happening.', $tokens);
    }

    if (isset($config['ldap_user_conf.ldapUserSyncMappings'])) {
      $to_ldap_entries_mappings_exist = FALSE;
      foreach ($config['ldap_user_conf.ldapUserSyncMappings'] as $sync_direction => $mappings) {
        $map_index = array();
        $tokens['%sid'] = $config['ldap_user_conf.drupalAcctProvisionServer'];
        $to_drupal_user_mappings_exist = FALSE;
        $to_ldap_entries_mappings_exist = FALSE;

        foreach ($mappings as $target_attr => $mapping) {
          if ($mapping['direction'] == LdapUserConf::$provisioningDirectionToDrupalUser) {
            $attr_value = $mapping['user_attr'];
            $attr_name = 'user_attr';
          }
          if ($mapping['direction'] == LdapUserConf::$provisioningDirectionToLDAPEntry) {
            $attr_value = $mapping['ldap_attr'];
            $attr_name = 'ldap_attr';
          }
          foreach ($values as $field => $value) {
            $parts = explode('__', $field);
            if (count($parts) == 4 && $parts[2] == $attr_name && $value == $attr_value) {
              $map_index[$attr_value] = $parts[3];
            }
          }
        }

        foreach ($mappings as $target_attr => $mapping) {
          foreach ($mapping as $key => $value) {
            if (is_scalar($value)) {
              $tokens['%' . $key] = $value;
            }
          }
          $row_descriptor = t("server %sid row mapping to ldap attribute %ldap_attr", $tokens);
          $tokens['!row_descriptor'] = $row_descriptor;
          $ldap_attribute_maps_in_token = array();
          $this->LdapUserConfHelper->extractTokenAttributes($ldap_attribute_maps_in_token, $mapping['ldap_attr']);

          if ($mapping['direction'] == LdapUserConf::$provisioningDirectionToDrupalUser) {
            $row_id = $map_index[$mapping['user_attr']];
            $to_drupal_user_mappings_exist = TRUE;
          }
          if ($mapping['direction'] == LdapUserConf::$provisioningDirectionToLDAPEntry) {
            $row_id = $map_index[$mapping['ldap_attr']];
            $to_ldap_entries_mappings_exist = TRUE;

            if (count(array_keys($ldap_attribute_maps_in_token)) != 1) {
              $token_field_id = join('__', array('sm', 'user_tokens', $row_id));
              $errors[$token_field_id] = t('When provisioning to ldap, ldap attribute column must be singular token such as [cn]. %ldap_attr is not.
                Do not use compound tokens such as "[displayName] [sn]" or literals such as "physics". Location: !row_descriptor', $tokens);
            }

          }
          // FIXME none of these id's should be working.
          $ldap_attr_field_id = join('__', array('sm', 'ldap_attr', $row_id));
          $user_attr_field_id = join('__', array('sm', 'user_attr', $row_id));
          $first_context_field_id = join('__', array('sm', 1, $row_id));
          $user_tokens_field_id = join('__', array('sm', 'user_tokens', $row_id));

          if (!$mapping['ldap_attr']) {
            $errors[$ldap_attr_field_id] = t('No LDAP Attribute given in !row_descriptor', $tokens);
          }
          if ($mapping['user_attr'] == 'user_tokens' && !$mapping['user_tokens']) {
            $errors[$user_tokens_field_id] = t('User tokens selected in !row_descriptor, but user tokens column empty.', $tokens);
          }

          if (isset($mapping['prov_events']) && count($mapping['prov_events']) == 0) {
            $warnings[$first_context_field_id] = t('No synchronization events checked in !row_descriptor.
              This field will not be synchronized until some are checked.', $tokens);
          }
        }
      }
      if ($to_ldap_entries_mappings_exist && !isset($mappings['dn'])) {
        $errors['mappings__' . $sync_direction] = t('Mapping rows exist for provisioning to LDAP, but no LDAP attribute is targeted for [dn].
          One row must map to [dn].  This row will have a user token like cn=[property.name],ou=users,dc=ldap,dc=mycompany,dc=com');
      }
    }
    return array($errors, $warnings);
  }

}
